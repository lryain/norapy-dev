#!/bin/bash

################################################################################
# OpenVoiceOS Development Mode Startup Script
# This script provides a simplified way to start OVOS in development mode
################################################################################

set -e

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
ENGINE_DIR="$PROJECT_ROOT/engine"
VENV_PATH="$ENGINE_DIR/venv"
LOG_DIR="$PROJECT_ROOT/logs"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

# 显示帮助信息
show_help() {
    cat << EOF
OpenVoiceOS Development Mode Startup Script

Usage: $0 [OPTIONS]

Options:
    -h, --help              Show this help message
    -s, --setup-only        Only setup environment, don't start services
    -v, --verbose           Enable verbose output
    -l, --language LANG     Set language (default: en-us)
    -j, --skip-mb           Skip message bus (assumes it's already running)
    -k, --kill              Kill all running OVOS processes
    -c, --clean             Clean cache and logs before starting

Examples:
    # Start OVOS with English
    $0 --language en-us
    
    # Start OVOS with Chinese
    $0 --language zh-cn
    
    # Only setup environment
    $0 --setup-only
    
    # Kill all OVOS processes
    $0 --kill

EOF
}

# 命令行参数解析
SETUP_ONLY=false
VERBOSE=false
LANGUAGE="en-us"
SKIP_MB=false
CLEAN=false
# If true, force-stop ovos-core and ovos_messagebus on exit even if not started by this script
FORCE_STOP=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -s|--setup-only)
            SETUP_ONLY=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -l|--language)
            LANGUAGE="$2"
            shift 2
            ;;
        -j|--skip-mb)
            SKIP_MB=true
            shift
            ;;
        -k|--kill)
            log_warn "Killing all OVOS processes..."
            pkill -f "ovos-core" 2>/dev/null || true
            pkill -f "ovos_messagebus" 2>/dev/null || true
            sleep 1
            log_success "All OVOS processes killed"
            exit 0
            ;;
        -c|--clean)
            CLEAN=true
            shift
            ;;
        -K|--force-stop)
            FORCE_STOP=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# 清理缓存（如果指定）
if [ "$CLEAN" = true ]; then
    log_info "Cleaning cache and logs..."
    rm -rf ~/.local/share/mycroft/cache/* 2>/dev/null || true
    rm -rf "$LOG_DIR"/* 2>/dev/null || true
    log_success "Cache and logs cleaned"
fi

echo ""
echo -e "${BLUE}╔══════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║     OpenVoiceOS Development Mode - Setup & Launch       ║${NC}"
echo -e "${BLUE}╚══════════════════════════════════════════════════════════╝${NC}"
echo ""

# 检查 Python
log_info "Checking Python version..."
if ! command -v python3 &> /dev/null; then
    log_error "Python3 not found. Please install Python 3.9+"
    exit 1
fi

PYTHON_VERSION=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')
log_success "Python $PYTHON_VERSION found"

# 创建虚拟环境（如果不存在）
if [ ! -d "$VENV_PATH" ]; then
    log_info "Creating Python virtual environment..."
    cd "$ENGINE_DIR"
    python3 -m venv venv
    source "$VENV_PATH/bin/activate"
    
    log_info "Upgrading pip and installing core packages..."
    pip install --quiet --upgrade pip setuptools wheel
    
    log_info "Installing OVOS development environment using workspace manager..."
    cd "$ENGINE_DIR"
    
    # Use workspace-based installation (faster, more organized)
    python3 install-workspaces.py core
    if [ $? -ne 0 ]; then
        log_error "Development environment installation failed"
        exit 1
    fi
else
    log_success "Virtual environment already exists"
    source "$VENV_PATH/bin/activate"
fi

# 创建日志目录
mkdir -p "$LOG_DIR"

# Message bus PID (set when we start it)
MB_PID=""
# Whether this script started the message bus
MB_STARTED=false

# OVOS core PID (set when we start it)
OVOS_PID=""
# PID of tail process streaming ovos-core log to stdout
TAIL_PID=""
# Additional service PIDs and flags
PHAL_PID=""
PHAL_STARTED=false
AUDIO_PID=""
AUDIO_STARTED=false
DINKUM_PID=""
DINKUM_STARTED=false

stop_messagebus() {
    if [ "$MB_STARTED" = true ] && [ -n "$MB_PID" ]; then
        # Check process still exists
        if kill -0 "$MB_PID" 2>/dev/null; then
            log_info "Stopping message bus (PID: $MB_PID)..."
            kill "$MB_PID" 2>/dev/null || true

            # wait up to 10 seconds for clean exit
            for i in {1..10}; do
                if kill -0 "$MB_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done

            # If still alive, force kill
            if kill -0 "$MB_PID" 2>/dev/null; then
                log_warn "Message bus did not exit, sending SIGKILL..."
                kill -9 "$MB_PID" 2>/dev/null || true
            fi

            # wait one final moment for reaping
            wait "$MB_PID" 2>/dev/null || true
            log_success "Message bus stopped"
            MB_PID=""
        fi
    fi
}

stop_phal() {
    if [ "$PHAL_STARTED" = true ] && [ -n "$PHAL_PID" ]; then
        if kill -0 "$PHAL_PID" 2>/dev/null; then
            log_info "Stopping OVOS PHAL (PID: $PHAL_PID)..."
            kill "$PHAL_PID" 2>/dev/null || true
            for i in {1..10}; do
                if kill -0 "$PHAL_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done
            if kill -0 "$PHAL_PID" 2>/dev/null; then
                log_warn "OVOS PHAL did not exit, sending SIGKILL to PID..."
                kill -9 "$PHAL_PID" 2>/dev/null || true
            fi
            # also try killing process group if present
            if [ -n "$PHAL_PID" ]; then
                PGID=$(ps -o pgid= -p "$PHAL_PID" 2>/dev/null | tr -d ' ')
                if [ -n "$PGID" ]; then
                    log_warn "Also sending SIGKILL to PHAL process group -$PGID"
                    kill -9 -"$PGID" 2>/dev/null || true
                fi
            fi
            wait "$PHAL_PID" 2>/dev/null || true
            log_success "OVOS PHAL stopped"
            PHAL_PID=""
            PHAL_STARTED=false
        fi
    fi
}

stop_audio() {
    if [ "$AUDIO_STARTED" = true ] && [ -n "$AUDIO_PID" ]; then
        if kill -0 "$AUDIO_PID" 2>/dev/null; then
            log_info "Stopping OVOS audio (PID: $AUDIO_PID)..."
            kill "$AUDIO_PID" 2>/dev/null || true
            for i in {1..10}; do
                if kill -0 "$AUDIO_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done
            if kill -0 "$AUDIO_PID" 2>/dev/null; then
                log_warn "OVOS audio did not exit, sending SIGKILL to PID..."
                kill -9 "$AUDIO_PID" 2>/dev/null || true
            fi
            if [ -n "$AUDIO_PID" ]; then
                PGID=$(ps -o pgid= -p "$AUDIO_PID" 2>/dev/null | tr -d ' ')
                if [ -n "$PGID" ]; then
                    log_warn "Also sending SIGKILL to AUDIO process group -$PGID"
                    kill -9 -"$PGID" 2>/dev/null || true
                fi
            fi
            wait "$AUDIO_PID" 2>/dev/null || true
            log_success "OVOS audio stopped"
            AUDIO_PID=""
            AUDIO_STARTED=false
        fi
    fi
}

stop_dinkum() {
    if [ "$DINKUM_STARTED" = true ] && [ -n "$DINKUM_PID" ]; then
        if kill -0 "$DINKUM_PID" 2>/dev/null; then
            log_info "Stopping OVOS dinkum listener (PID: $DINKUM_PID)..."
            kill "$DINKUM_PID" 2>/dev/null || true
            for i in {1..10}; do
                if kill -0 "$DINKUM_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done
            if kill -0 "$DINKUM_PID" 2>/dev/null; then
                log_warn "OVOS dinkum listener did not exit, sending SIGKILL to PID..."
                kill -9 "$DINKUM_PID" 2>/dev/null || true
            fi
            if [ -n "$DINKUM_PID" ]; then
                PGID=$(ps -o pgid= -p "$DINKUM_PID" 2>/dev/null | tr -d ' ')
                if [ -n "$PGID" ]; then
                    log_warn "Also sending SIGKILL to DINKUM process group -$PGID"
                    kill -9 -"$PGID" 2>/dev/null || true
                fi
            fi
            wait "$DINKUM_PID" 2>/dev/null || true
            log_success "OVOS dinkum listener stopped"
            DINKUM_PID=""
            DINKUM_STARTED=false
        fi
    fi
}

stop_tail() {
    if [ -n "$TAIL_PID" ]; then
        if kill -0 "$TAIL_PID" 2>/dev/null; then
            log_info "Stopping log tail (PID: $TAIL_PID)..."
            kill "$TAIL_PID" 2>/dev/null || true
            for i in {1..5}; do
                if kill -0 "$TAIL_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done
            if kill -0 "$TAIL_PID" 2>/dev/null; then
                    log_warn "Tail did not exit, sending SIGKILL to PID..."
                    kill -9 "$TAIL_PID" 2>/dev/null || true
                fi
                if [ -n "$TAIL_PID" ]; then
                    PGID=$(ps -o pgid= -p "$TAIL_PID" 2>/dev/null | tr -d ' ')
                    if [ -n "$PGID" ]; then
                        log_warn "Also sending SIGKILL to TAIL process group -$PGID"
                        kill -9 -"$PGID" 2>/dev/null || true
                    fi
                fi
                wait "$TAIL_PID" 2>/dev/null || true
            log_success "Log tail stopped"
            TAIL_PID=""
        fi
    fi
}

# 创建/更新配置文件
log_info "Setting up configuration..."
CONFIG_DIR="$HOME/.config/mycroft"
CONFIG_FILE="$CONFIG_DIR/mycroft.conf"


log_success "Configuration ready"
echo ""

# 如果只是设置环境，则退出
if [ "$SETUP_ONLY" = true ]; then
    log_success "Environment setup complete!"
    log_info "To start OVOS, run: $0"
    exit 0
fi

echo -e "${BLUE}Starting Services...${NC}"
echo ""

# 启动消息总线（如果未指定跳过）
if [ "$SKIP_MB" = false ]; then
    log_info "Starting message bus..."
    
    # 检查端口是否已被占用 - 使用 python 方法
    if python3 -c "import socket; s = socket.socket(); s.bind(('localhost', 8181)); s.close()" 2>/dev/null; then
        # 端口是空闲的，启动 messagebus
        cd "$ENGINE_DIR"
        python3 -m ovos_messagebus > "$LOG_DIR/messagebus.log" 2>&1 &
        MB_PID=$!
        MB_STARTED=true
        
        # 等待消息总线启动
        sleep 3
        
        # 再次检查端口
        if ! python3 -c "import socket; s = socket.socket(); s.bind(('localhost', 8181)); s.close()" 2>/dev/null; then
            log_success "Message bus started (PID: $MB_PID)"
        else
            log_error "Message bus failed to start"
            log_error "Check log: tail -40 $LOG_DIR/messagebus.log"
            exit 1
        fi
    else
        log_warn "Message bus already running on port 8181"
    fi
else
    log_info "Skipping message bus startup (assuming already running)"
fi

sleep 1
echo ""
log_info "Starting OVOS core..."
cd "$ENGINE_DIR"

# 构建 OVOS 启动参数
OVOS_ARGS=""
if [ "$VERBOSE" = true ]; then
    export OVOS_LOG_LEVEL=DEBUG
    log_info "Debug logging enabled"
fi


# Ensure we clean up messagebus and ovos-core when this script exits
on_exit() {
    log_warn "OVOS stopped"

    # Stop OVOS core if we started it
    if [ -n "$OVOS_PID" ]; then
        if kill -0 "$OVOS_PID" 2>/dev/null; then
            log_info "Stopping OVOS core (PID: $OVOS_PID)..."
            kill "$OVOS_PID" 2>/dev/null || true

            # wait up to 10 seconds
            for i in {1..10}; do
                if kill -0 "$OVOS_PID" 2>/dev/null; then
                    sleep 1
                else
                    break
                fi
            done

            if kill -0 "$OVOS_PID" 2>/dev/null; then
                log_warn "OVOS core did not exit, sending SIGKILL..."
                kill -9 "$OVOS_PID" 2>/dev/null || true
            fi

            wait "$OVOS_PID" 2>/dev/null || true
            log_success "OVOS core stopped"
            OVOS_PID=""
        fi
    else
        # Fallback: try to kill any ovos-core processes if present and user requested cleanup
        if [ "$FORCE_STOP" = true ]; then
            log_warn "Force stopping ovos-core processes..."
            pkill -f "ovos-core" 2>/dev/null || true
        fi
    fi

    # Stop additional services we may have started
    stop_tail
    stop_dinkum
    stop_audio
    stop_phal

    # Fallback: if any of those processes are still lingering, forcibly pkill by pattern
    if pgrep -f ovos-dinkum-listener >/dev/null 2>&1; then
        log_warn "Reaping lingering ovos-dinkum-listener processes..."
        pkill -f ovos-dinkum-listener 2>/dev/null || true
    fi

    if pgrep -f "tail -n +1 -f" >/dev/null 2>&1; then
        log_warn "Reaping lingering tail processes..."
        pkill -f "tail -n +1 -f" 2>/dev/null || true
    fi

    # Stop message bus if we started it; if force-stop requested, kill any messagebus processes
    if [ "$FORCE_STOP" = true ]; then
        log_warn "Force stopping ovos_messagebus processes..."
        pkill -f "ovos_messagebus" 2>/dev/null || true
        # also attempt to reap PID if set
        stop_messagebus
    else
        stop_messagebus
    fi
}
trap on_exit EXIT INT TERM

# Start dependent services in order: PHAL -> audio -> dinkum -> core

# Start PHAL
if [ "$SKIP_MB" = false ]; then
    log_info "Starting OVOS PHAL..."
    if command -v ovos_PHAL >/dev/null 2>&1; then
        OVOS_PHAL_LOG="$LOG_DIR/ovos-phal.log"
        setsid ovos_PHAL > "$OVOS_PHAL_LOG" 2>&1 &
        PHAL_PID=$!
        PHAL_STARTED=true
        sleep 2
        if kill -0 "$PHAL_PID" 2>/dev/null; then
            log_success "OVOS PHAL started (PID: $PHAL_PID)"
        else
            log_error "OVOS PHAL failed to start. Check log: tail -40 $OVOS_PHAL_LOG"
            tail -n 40 "$OVOS_PHAL_LOG" || true
            on_exit
            exit 1
        fi
    else
        log_warn "ovos_PHAL binary not found in PATH, skipping PHAL startup"
    fi
fi

# Start ovos-audio
log_info "Starting OVOS audio daemon..."
if command -v ovos-audio >/dev/null 2>&1; then
    OVOS_AUDIO_LOG="$LOG_DIR/ovos-audio.log"
    setsid ovos-audio > "$OVOS_AUDIO_LOG" 2>&1 &
    AUDIO_PID=$!
    AUDIO_STARTED=true
    sleep 2
    if kill -0 "$AUDIO_PID" 2>/dev/null; then
        log_success "OVOS audio started (PID: $AUDIO_PID)"
    else
        log_error "OVOS audio failed to start. Check log: tail -40 $OVOS_AUDIO_LOG"
        tail -n 40 "$OVOS_AUDIO_LOG" || true
        on_exit
        exit 1
    fi
else
    log_warn "ovos-audio binary not found in PATH, skipping audio startup"
fi

# Start dinkum listener
log_info "Starting OVOS dinkum listener..."
if command -v ovos-dinkum-listener >/dev/null 2>&1; then
    OVOS_DINKUM_LOG="$LOG_DIR/ovos-dinkum-listener.log"
    setsid ovos-dinkum-listener > "$OVOS_DINKUM_LOG" 2>&1 &
    DINKUM_PID=$!
    DINKUM_STARTED=true
    sleep 2
    if kill -0 "$DINKUM_PID" 2>/dev/null; then
        log_success "OVOS dinkum listener started (PID: $DINKUM_PID)"
    else
        log_error "OVOS dinkum listener failed to start. Check log: tail -40 $OVOS_DINKUM_LOG"
        tail -n 40 "$OVOS_DINKUM_LOG" || true
        on_exit
        exit 1
    fi
else
    log_warn "ovos-dinkum-listener not found in PATH, skipping listener startup"
fi

# 启动 OVOS core (background so we can trap and stop it)
OVOS_LOG_FILE="$LOG_DIR/ovos-core.log"
mkdir -p "$(dirname "$OVOS_LOG_FILE")"
setsid ovos-core $OVOS_ARGS > "$OVOS_LOG_FILE" 2>&1 &
OVOS_PID=$!
log_info "OVOS core started (PID: $OVOS_PID), logging to $OVOS_LOG_FILE"

# Stream the ovos-core log to our stdout so the user sees initialization (will be killed on exit)
setsid tail -n +1 -f "$OVOS_LOG_FILE" &
TAIL_PID=$!

# Wait for ovos-core to exit; trap will handle cleanup and will also kill the tail
wait "$OVOS_PID"

# If ovos-core exited, stop the tail
if [ -n "$TAIL_PID" ]; then
    kill "$TAIL_PID" 2>/dev/null || true
    TAIL_PID=""
fi

echo ""
echo -e "${YELLOW}OVOS has stopped${NC}"
log_info "To view logs, run:"
echo "  tail -f $LOG_DIR/messagebus.log"
echo "  tail -f ~/.local/share/mycroft/logs/skills.log"
